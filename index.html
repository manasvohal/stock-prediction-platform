<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #3a86ff;
            --primary-dark: #2667cc;
            --success: #34c759;
            --danger: #ff3b30;
            --warning: #ff9500;
            --dark: #212529;
            --light: #f8f9fa;
            --gray: #8e8e93;
            --border-radius: 12px;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--light);
            color: var(--dark);
            line-height: 1.6;
        }
        
        .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .nav-logo {
            font-size: 22px;
            font-weight: bold;
            color: var(--dark);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .nav-logo:before {
            content: '\f201';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            color: var(--primary);
        }
        
        .nav-logo:hover {
            color: var(--primary);
        }
        
        .nav-links {
            display: flex;
            gap: 25px;
        }
        
        .nav-link {
            color: var(--dark);
            text-decoration: none;
            padding: 8px 0;
            position: relative;
            font-weight: 500;
            transition: var(--transition);
        }
        
        .nav-link:hover {
            color: var(--primary);
        }
        
        .nav-link.active {
            font-weight: 600;
            color: var(--primary);
        }
        
        .nav-link.active:after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: var(--primary);
            border-radius: 3px;
        }
        
        .search-container {
            display: flex;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border-radius: var(--border-radius);
            overflow: hidden;
        }
        
        .search-input {
            flex: 1;
            padding: 16px 20px;
            font-size: 16px;
            border: none;
            outline: none;
            background: white;
        }
        
        .search-button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0 25px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 100px;
            justify-content: center;
        }
        
        .search-button:disabled {
            background-color: #999;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .search-button:hover:not(:disabled) {
            background-color: var(--primary-dark);
        }
        
        .search-button:before {
            content: '\f002';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
        }
        
        .search-button.loading:before {
            content: '\f110';
            animation: fa-spin 2s linear infinite;
        }
        
        @keyframes fa-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .stock-container, .technical-container, .sentiment-container, .prediction-container {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--shadow);
            margin-bottom: 30px;
            transition: var(--transition);
        }
        
        .stock-container:hover, .technical-container:hover, .sentiment-container:hover, .prediction-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        }
        
        .stock-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 25px;
        }
        
        .ticker {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 5px;
            color: var(--dark);
        }
        
        .company-name {
            font-size: 18px;
            color: #666;
        }
        
        .price {
            font-size: 32px;
            font-weight: 700;
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.03);
            border-radius: var(--border-radius);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .chart-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--dark);
        }
        
        .timeframe-selector {
            display: flex;
            gap: 8px;
            background-color: rgba(0,0,0,0.03);
            padding: 4px;
            border-radius: 8px;
        }
        
        .timeframe-button {
            padding: 8px 16px;
            background-color: transparent;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .timeframe-button:hover {
            background-color: rgba(0,0,0,0.05);
        }
        
        .timeframe-button.active {
            background-color: var(--primary);
            color: white;
        }
        
        .chart-container {
            height: 550px;
            position: relative;
            margin-bottom: 20px;
            background-color: white;
            border-radius: var(--border-radius);
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.9);
            z-index: 10;
            border-radius: var(--border-radius);
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(58, 134, 255, 0.2);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .positive {
            color: var(--success);
        }
        
        .negative {
            color: var(--danger);
        }
        
        .error-message {
            color: var(--danger);
            text-align: center;
            padding: 20px;
            background-color: rgba(217, 4, 41, 0.05);
            border-radius: var(--border-radius);
        }
        
        .not-found {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }
        
        .technical-header, .technical-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            color: var(--dark);
        }
        
        .technical-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }
        
        .technical-section {
            margin-bottom: 25px;
        }
        
        .technical-section h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #555;
            font-weight: 600;
        }
        
        .indicator {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .indicator-name {
            color: #666;
            font-weight: 500;
        }
        
        .indicator-value {
            font-weight: 600;
        }
        
        .trend-strong-up {
            color: var(--success);
            font-weight: bold;
        }
        
        .trend-up {
            color: var(--success);
        }
        
        .trend-neutral {
            color: #666;
        }
        
        .trend-down {
            color: var(--danger);
        }
        
        .trend-strong-down {
            color: var(--danger);
            font-weight: bold;
        }
        
        .summary-box {
            background-color: rgba(0,0,0,0.02);
            border-radius: 10px;
            padding: 20px;
            margin-top: 15px;
            line-height: 1.7;
        }
        
        .pattern-item {
            background-color: rgba(0,0,0,0.03);
            border-radius: 20px;
            padding: 8px 15px;
            margin-right: 10px;
            margin-bottom: 10px;
            display: inline-block;
            font-size: 14px;
            font-weight: 500;
        }
        
        /* Sentiment Analysis Styles */
        .sentiment-score-container {
            padding: 20px 0;
        }
        
        .sentiment-meter {
            height: 12px;
            background-color: rgba(0,0,0,0.05);
            border-radius: 6px;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .sentiment-meter-bar {
            height: 100%;
            background-color: var(--success);
            width: 50%;
            transition: width 0.5s ease, background-color 0.5s ease;
        }
        
        .sentiment-label {
            text-align: center;
            font-weight: 600;
            font-size: 18px;
        }
        
        .sentiment-distribution {
            display: flex;
            justify-content: space-between;
            height: 180px;
            margin-top: 20px;
        }
        
        .distribution-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 15px;
        }
        
        .distribution-label {
            margin-bottom: 10px;
            font-size: 15px;
            font-weight: 500;
        }
        
        .distribution-bar-container {
            width: 40px;
            height: 120px;
            background-color: rgba(0,0,0,0.03);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .distribution-bar {
            position: absolute;
            bottom: 0;
            width: 100%;
            transition: height 0.5s ease;
        }
        
        .positive-bar {
            background-color: var(--success);
            height: 60%;
        }
        
        .neutral-bar {
            background-color: #999;
            height: 30%;
        }
        
        .negative-bar {
            background-color: var(--danger);
            height: 10%;
        }
        
        .distribution-value {
            font-weight: 600;
            font-size: 16px;
        }
        
        .articles-container {
            max-height: 350px;
            overflow-y: auto;
            padding-right: 10px;
            margin-top: 10px;
        }
        
        .article-item {
            padding: 15px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            border-radius: 8px;
            margin-bottom: 10px;
            transition: var(--transition);
            cursor: pointer;
        }
        
        .article-item:hover {
            background-color: rgba(0,0,0,0.02);
        }
        
        .article-item h4 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 600;
        }
        
        .article-item p {
            margin: 8px 0;
            font-size: 14px;
            color: #666;
        }
        
        .article-loading {
            text-align: center;
            color: #666;
            padding: 20px;
        }
        
        /* Prediction Styles */
        .prediction-main {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            gap: 25px;
        }
        
        .recommendation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }
        
        .recommendation {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 15px;
            padding: 20px 40px;
            border-radius: 12px;
            text-align: center;
            width: 100%;
            max-width: 200px;
        }
        
        .recommendation.buy {
            background-color: var(--success);
            color: white;
        }
        
        .recommendation.hold {
            background-color: #ffbe0b;
            color: #333;
        }
        
        .recommendation.sell {
            background-color: var(--danger);
            color: white;
        }
        
        .confidence {
            font-size: 16px;
            color: #666;
            font-weight: 500;
        }
        
        .prediction-details {
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex: 1;
            background-color: rgba(0,0,0,0.02);
            border-radius: 12px;
            padding: 20px;
        }
        
        .prediction-item {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .prediction-label {
            color: #666;
            font-weight: 500;
        }
        
        .prediction-value {
            font-weight: 600;
        }
        
        .factors-container {
            margin-top: 30px;
        }
        
        .factors-container h3 {
            font-size: 18px;
            margin-bottom: 20px;
            color: var(--dark);
            font-weight: 600;
        }
        
        .factors-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 25px;
        }
        
        .factor-section h4 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #555;
            font-weight: 500;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        .factors-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .factors-list li {
            padding: 10px 0;
            font-size: 14px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        
        /* ML Forecast Styles */
        .chart-tabs {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .chart-tab {
            background: none;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            border-radius: 8px;
        }
        
        .chart-tab:hover {
            color: var(--primary);
            background-color: rgba(58, 134, 255, 0.05);
        }
        
        .chart-tab.active {
            color: var(--primary);
            background-color: rgba(58, 134, 255, 0.1);
        }
        
        .chart-tab.active:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: var(--primary);
            border-radius: 3px;
        }
        
        .chart-content {
            margin-top: 20px;
            position: relative;
        }
        
        .ml-metrics {
            display: flex;
            justify-content: space-between;
            margin: 25px 0;
            gap: 20px;
        }
        
        .ml-metric {
            flex: 1;
            background-color: white;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: var(--transition);
            border-top: 3px solid transparent;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .ml-metric:nth-child(1) {
            border-top-color: var(--primary);
        }
        
        .ml-metric:nth-child(2) {
            border-top-color: var(--warning);
        }
        
        .ml-metric:nth-child(3) {
            border-top-color: var(--gray);
        }
        
        .ml-metric:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }
        
        .ml-metric-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .ml-metric-value {
            font-size: 28px;
            font-weight: 600;
            color: var(--dark);
        }
        
        .ml-metric-value.positive {
            color: var(--success);
        }
        
        .ml-metric-value.negative {
            color: var(--danger);
        }
        
        .ml-info-panel {
            margin-top: 25px;
            padding: 20px;
            background-color: white;
            border-radius: var(--border-radius);
            border-left: 4px solid var(--primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .ml-info-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--dark);
            display: flex;
            align-items: center;
        }
        
        .ml-info-content {
            font-size: 15px;
            line-height: 1.6;
            color: #555;
        }
        
        .ml-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
            vertical-align: middle;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .ml-badge-beta {
            background-color: var(--warning);
            color: white;
        }
        
        .ml-legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .ml-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #555;
        }
        
        .ml-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .ml-legend-historical {
            background-color: #3a86ff;
        }
        
        .ml-legend-forecast {
            background-color: #38b000;
        }
        
        .ml-legend-confidence {
            background-color: rgba(56, 176, 0, 0.3);
        }
        
        .ml-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            margin-left: 8px;
            vertical-align: middle;
        }
        
        .ml-badge-beta {
            background-color: #ff9500;
            color: white;
        }
        
        .ml-badge-new {
            background-color: var(--primary);
            color: white;
        }
        
        .ml-badge-beta {
            background-color: #ff9500;
            color: white;
        }

        /* Responsive styles */
        @media (max-width: 992px) {
            .technical-grid, .factors-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .prediction-main {
                flex-direction: column;
            }
            
            .technical-grid, .factors-grid {
                grid-template-columns: 1fr;
            }
            
            .recommendation {
                max-width: 100%;
            }
        }
        
        @media (max-width: 576px) {
            .nav-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            
            .nav-links {
                width: 100%;
                justify-content: space-between;
            }
            
            .stock-header {
                flex-direction: column;
                gap: 15px;
            }
            
            .price {
                align-self: flex-start;
            }
            
            .chart-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            
            .timeframe-selector {
                width: 100%;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div class="nav-header">
        <a href="/" class="nav-logo">Stock Predictor</a>
        <div class="nav-links">
            <a href="/" class="nav-link">Dashboard</a>
            <a href="/portfolio.html" class="nav-link">Portfolio</a>
            <a href="/analysis.html" class="nav-link">Analysis</a>
        </div>
    </div>

    <div class="search-container">
        <input type="text" id="ticker-search" class="search-input" placeholder="Enter stock ticker (e.g., AAPL, MSFT, GOOGL)" value="AAPL">
        <button id="search-button" class="search-button">Search</button>
    </div>
    
    <div class="stock-container">
        <div class="stock-header">
            <div>
                <div class="ticker" id="ticker">Loading...</div>
                <div class="company-name" id="company-name"></div>
            </div>
            <div class="price" id="price">Loading...</div>
        </div>
        
        <div class="chart-header">
            <div class="chart-title">Price Chart</div>
            <div class="timeframe-selector">
                <button class="timeframe-button active" data-days="7">1W</button>
                <button class="timeframe-button" data-days="30">1M</button>
                <button class="timeframe-button" data-days="90">3M</button>
                <button class="timeframe-button" data-days="365">1Y</button>
            </div>
        </div>
        
        <div class="chart-container">
            <div class="loading" id="loading">
                <div class="loading-spinner"></div>
            </div>
            <div id="chart"></div>
        </div>
        
        <div class="chart-tabs">
            <button class="chart-tab active" data-tab="price">Price Chart</button>
            <button class="chart-tab" data-tab="ml">ML Forecast</button>
        </div>
        
        <div class="chart-content" id="price-chart-content">
            <!-- Price chart is already displayed above -->
        </div>
        
        <div class="chart-content" id="ml-chart-content" style="display: none;">
            <div class="loading" id="ml-loading">
                <div class="loading-spinner"></div>
            </div>
            <div id="ml-chart"></div>
            <div class="ml-legend">
                <div class="ml-legend-item">
                    <div class="ml-legend-color ml-legend-historical"></div>
                    <span>Historical Data</span>
                </div>
                <div class="ml-legend-item">
                    <div class="ml-legend-color ml-legend-forecast"></div>
                    <span>ML Forecast</span>
                </div>
            </div>
            <div class="ml-metrics">
                <div class="ml-metric">
                    <div class="ml-metric-label">30-Day Forecast</div>
                    <div class="ml-metric-value" id="ml-forecast-value">-</div>
                </div>
                <div class="ml-metric">
                    <div class="ml-metric-label">Predicted Change</div>
                    <div class="ml-metric-value" id="ml-change-value">-</div>
                </div>
                <div class="ml-metric">
                    <div class="ml-metric-label">Model Accuracy</div>
                    <div class="ml-metric-value" id="ml-accuracy-value">-</div>
                </div>
            </div>
            <div class="ml-info-panel">
                <div class="ml-info-title">
                    AI Prediction Model <span class="ml-badge ml-badge-beta">BETA</span>
                </div>
                <div class="ml-info-content">
                    This forecast is generated using an advanced LSTM neural network trained on historical price data and technical indicators. The model analyzes patterns in price movements, volatility, and momentum to predict future price trends. Accuracy is measured by the model's ability to predict price direction correctly.
                </div>
            </div>
        </div>
    </div>

    <div class="technical-container">
        <div class="technical-header">Technical Analysis</div>
        <div class="loading" id="technical-loading">
            <div class="loading-spinner"></div>
        </div>
        <div id="technical-content">
            <div class="technical-grid">
                <div class="technical-section">
                    <h3>Summary</h3>
                    <div class="summary-box" id="technical-summary">Loading...</div>
                </div>
                <div class="technical-section">
                    <h3>Trend Analysis</h3>
                    <div class="indicator">
                        <span class="indicator-name">Current Trend</span>
                        <span class="indicator-value" id="trend">-</span>
                    </div>
                    <div class="indicator">
                        <span class="indicator-name">Price Change</span>
                        <span class="indicator-value" id="price-change">-</span>
                    </div>
                </div>
                <div class="technical-section">
                    <h3>Moving Averages</h3>
                    <div class="indicator">
                        <span class="indicator-name">MA (20)</span>
                        <span class="indicator-value" id="ma20">-</span>
                    </div>
                    <div class="indicator">
                        <span class="indicator-name">MA (50)</span>
                        <span class="indicator-value" id="ma50">-</span>
                    </div>
                    <div class="indicator">
                        <span class="indicator-name">MA (200)</span>
                        <span class="indicator-value" id="ma200">-</span>
                    </div>
                </div>
                <div class="technical-section">
                    <h3>Oscillators</h3>
                    <div class="indicator">
                        <span class="indicator-name">RSI (14)</span>
                        <span class="indicator-value" id="rsi">-</span>
                    </div>
                    <div class="indicator">
                        <span class="indicator-name">MACD</span>
                        <span class="indicator-value" id="macd">-</span>
                    </div>
                </div>
                <div class="technical-section">
                    <h3>Support & Resistance</h3>
                    <div class="indicator">
                        <span class="indicator-name">Support</span>
                        <span class="indicator-value" id="support">-</span>
                    </div>
                    <div class="indicator">
                        <span class="indicator-name">Resistance</span>
                        <span class="indicator-value" id="resistance">-</span>
                    </div>
                </div>
                <div class="technical-section">
                    <h3>Detected Patterns</h3>
                    <div id="patterns">-</div>
                </div>
            </div>
        </div>
    </div>

    <div class="sentiment-container technical-container">
        <div class="technical-header">Sentiment Analysis</div>
        <div class="loading" id="sentiment-loading">
            <div class="loading-spinner"></div>
        </div>
        <div id="sentiment-content">
            <div class="technical-grid">
                <div class="technical-section">
                    <h3>Sentiment Summary</h3>
                    <div class="summary-box" id="sentiment-summary">Loading...</div>
                </div>
                <div class="technical-section">
                    <h3>Sentiment Score</h3>
                    <div class="sentiment-score-container">
                        <div class="sentiment-meter">
                            <div class="sentiment-meter-bar" id="sentiment-meter-bar"></div>
                        </div>
                        <div class="sentiment-label" id="sentiment-label">-</div>
                    </div>
                </div>
                <div class="technical-section">
                    <h3>News Sentiment Distribution</h3>
                    <div class="sentiment-distribution">
                        <div class="distribution-item">
                            <div class="distribution-label">Positive</div>
                            <div class="distribution-bar-container">
                                <div class="distribution-bar positive-bar" id="positive-bar"></div>
                            </div>
                            <div class="distribution-value" id="positive-value">-</div>
                        </div>
                        <div class="distribution-item">
                            <div class="distribution-label">Neutral</div>
                            <div class="distribution-bar-container">
                                <div class="distribution-bar neutral-bar" id="neutral-bar"></div>
                            </div>
                            <div class="distribution-value" id="neutral-value">-</div>
                        </div>
                        <div class="distribution-item">
                            <div class="distribution-label">Negative</div>
                            <div class="distribution-bar-container">
                                <div class="distribution-bar negative-bar" id="negative-bar"></div>
                            </div>
                            <div class="distribution-value" id="negative-value">-</div>
                        </div>
                    </div>
                </div>
                <div class="technical-section">
                    <h3>Recent News Articles</h3>
                    <div class="articles-container" id="articles-container">
                        <div class="article-loading">Loading articles...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="prediction-container technical-container">
        <div class="technical-header">AI Prediction</div>
        <div class="loading" id="prediction-loading">
            <div class="loading-spinner"></div>
        </div>
        <div id="prediction-content">
            <div class="prediction-main">
                <div class="recommendation-container">
                    <div class="recommendation" id="recommendation">-</div>
                    <div class="confidence">
                        <span>Confidence:</span>
                        <span id="confidence-value">-</span>
                    </div>
                </div>
                <div class="prediction-details">
                    <div class="prediction-item">
                        <div class="prediction-label">Current Price</div>
                        <div class="prediction-value" id="current-price-prediction">-</div>
                    </div>
                    <div class="prediction-item">
                        <div class="prediction-label">Predicted Change</div>
                        <div class="prediction-value" id="predicted-change">-</div>
                    </div>
                    <div class="prediction-item">
                        <div class="prediction-label">Predicted Return</div>
                        <div class="prediction-value" id="predicted-return">-</div>
                    </div>
                </div>
            </div>
            <div class="summary-box" id="prediction-summary">Loading prediction analysis...</div>
            <div class="factors-container">
                <h3>Key Factors</h3>
                <div class="factors-grid">
                    <div class="factor-section">
                        <h4>Technical Factors</h4>
                        <ul id="technical-factors" class="factors-list">
                            <li>Loading factors...</li>
                        </ul>
                    </div>
                    <div class="factor-section">
                        <h4>Fundamental Factors</h4>
                        <ul id="fundamental-factors" class="factors-list">
                            <li>Loading factors...</li>
                        </ul>
                    </div>
                    <div class="factor-section">
                        <h4>Sentiment Factors</h4>
                        <ul id="sentiment-factors" class="factors-list">
                            <li>Loading factors...</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:8001/api/v1';
        let chart = null;
        let currentTicker = 'AAPL';
        let currentTimeframe = 7; // Default to 1 week

        async function fetchStockInfo(ticker) {
            try {
                console.log(`Fetching stock info for ${ticker}...`);
                const response = await fetch(`${API_URL}/stocks/${ticker}`);
                if (!response.ok) {
                    throw new Error(`Stock not found: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Stock info received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching stock info:', error);
                return null;
            }
        }

        async function fetchStockChart(ticker) {
            try {
                console.log(`Fetching chart data for ${ticker}...`);
                const response = await fetch(`${API_URL}/stocks/${ticker}/chart`);
                if (!response.ok) {
                    throw new Error(`Chart data not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Chart data received:`, data);
                return data.data || data; // Handle both formats
            } catch (error) {
                console.error('Error fetching chart data:', error);
                return null;
            }
        }

        async function fetchTechnicalAnalysis(ticker, period = '1y') {
            try {
                console.log(`Fetching technical analysis for ${ticker}...`);
                const response = await fetch(`${API_URL}/technical/${ticker}?period=${period}`);
                if (!response.ok) {
                    throw new Error(`Technical analysis not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Technical analysis received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching technical analysis:', error);
                return null;
            }
        }

        async function fetchTechnicalSummary(ticker, period = '1y') {
            try {
                console.log(`Fetching technical summary for ${ticker}...`);
                const response = await fetch(`${API_URL}/technical/${ticker}/summary?period=${period}`);
                if (!response.ok) {
                    throw new Error(`Technical summary not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Technical summary received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching technical summary:', error);
                return null;
            }
        }

        async function fetchSupportResistance(ticker, period = '1y') {
            try {
                console.log(`Fetching support/resistance for ${ticker}...`);
                const response = await fetch(`${API_URL}/technical/${ticker}/support-resistance?period=${period}`);
                if (!response.ok) {
                    throw new Error(`Support/resistance data not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Support/resistance data received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching support/resistance data:', error);
                return null;
            }
        }

        async function fetchPatterns(ticker, period = '1y') {
            try {
                console.log(`Fetching patterns for ${ticker}...`);
                const response = await fetch(`${API_URL}/technical/${ticker}/patterns?period=${period}`);
                if (!response.ok) {
                    throw new Error(`Pattern data not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Pattern data received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching pattern data:', error);
                return null;
            }
        }

        async function fetchSentimentScore(ticker, days = 7) {
            try {
                console.log(`Fetching sentiment score for ${ticker}...`);
                const response = await fetch(`${API_URL}/sentiment/${ticker}/score?days=${days}`);
                if (!response.ok) {
                    throw new Error(`Sentiment score not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Sentiment score received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching sentiment score:', error);
                return null;
            }
        }

        async function fetchSentimentDistribution(ticker, days = 7) {
            try {
                console.log(`Fetching sentiment distribution for ${ticker}...`);
                const response = await fetch(`${API_URL}/sentiment/${ticker}/distribution?days=${days}`);
                if (!response.ok) {
                    throw new Error(`Sentiment distribution not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Sentiment distribution received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching sentiment distribution:', error);
                return null;
            }
        }

        async function fetchNewsArticles(ticker, days = 7) {
            try {
                console.log(`Fetching news articles for ${ticker}...`);
                const response = await fetch(`${API_URL}/sentiment/${ticker}/articles?days=${days}`);
                if (!response.ok) {
                    throw new Error(`News articles not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`News articles received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching news articles:', error);
                return null;
            }
        }

        async function fetchSentimentSummary(ticker, days = 7) {
            try {
                console.log(`Fetching sentiment summary for ${ticker}...`);
                const response = await fetch(`${API_URL}/sentiment/${ticker}/summary?days=${days}`);
                if (!response.ok) {
                    throw new Error(`Sentiment summary not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Sentiment summary received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching sentiment summary:', error);
                return null;
            }
        }

        async function fetchPrediction(ticker) {
            try {
                console.log(`Fetching prediction for ${ticker}...`);
                const response = await fetch(`${API_URL}/predict/${ticker}`);
                if (!response.ok) {
                    throw new Error(`Prediction not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Prediction received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching prediction:', error);
                return null;
            }
        }

        async function fetchPredictionSummary(ticker) {
            try {
                console.log(`Fetching prediction summary for ${ticker}...`);
                const response = await fetch(`${API_URL}/predict/${ticker}/summary`);
                if (!response.ok) {
                    throw new Error(`Prediction summary not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Prediction summary received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching prediction summary:', error);
                return null;
            }
        }

        async function fetchPredictionFactors(ticker) {
            try {
                console.log(`Fetching prediction factors for ${ticker}...`);
                const response = await fetch(`${API_URL}/predict/${ticker}/factors`);
                if (!response.ok) {
                    throw new Error(`Prediction factors not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`Prediction factors received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching prediction factors:', error);
                return null;
            }
        }
        
        async function fetchMLPrediction(ticker) {
            try {
                console.log(`Fetching ML prediction for ${ticker}...`);
                const response = await fetch(`${API_URL}/predict/${ticker}/ml`);
                if (!response.ok) {
                    throw new Error(`ML prediction not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`ML prediction received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching ML prediction:', error);
                return null;
            }
        }
        
        async function fetchMLEvaluation(ticker) {
            try {
                console.log(`Fetching ML evaluation for ${ticker}...`);
                const response = await fetch(`${API_URL}/predict/${ticker}/ml/evaluate`);
                if (!response.ok) {
                    throw new Error(`ML evaluation not found for: ${ticker}`);
                }
                const data = await response.json();
                console.log(`ML evaluation received:`, data);
                return data;
            } catch (error) {
                console.error('Error fetching ML evaluation:', error);
                return null;
            }
        }

        function processChartData(chartData, days) {
            if (!chartData || !Array.isArray(chartData) || chartData.length === 0) {
                console.error('Invalid chart data format');
                return null;
            }

            console.log(`Processing ${chartData.length} data points for ${days} days...`);
            
            // Get data from the specified timeframe
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - days);
            
            const filteredData = chartData.filter(item => new Date(item.date) >= cutoffDate);
            console.log(`Filtered to ${filteredData.length} data points within the timeframe`);
            
            // For candlestick chart, we need OHLC data
            return filteredData.map(item => ({
                x: new Date(item.date).getTime(),
                y: [item.open, item.high, item.low, item.close]
            }));
        }

        async function createChart(ticker, days, chartData = null) {
            try {
                // If chartData is provided, use it for the chart
                if (chartData && Array.isArray(chartData) && chartData.length > 1) {
                    document.getElementById('loading').style.display = 'flex';
                    
                    const processedData = processChartData(chartData, days);
                    if (!processedData || processedData.length === 0) {
                        document.getElementById('chart').innerHTML = '<div class="error-message">Unable to process chart data</div>';
                        document.getElementById('loading').style.display = 'none';
                        return null;
                    }
                    
                    // Determine appropriate chart type and options based on timeframe
                    const isSmallTimeframe = days <= 7;
                    
                    const options = {
                        series: [{
                            name: ticker,
                            data: processedData
                        }],
                        chart: {
                            type: 'candlestick',
                            height: 500,
                            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif',
                            background: 'transparent',
                            animations: {
                                enabled: true,
                                easing: 'easeinout',
                                speed: 800
                            },
                            toolbar: {
                                show: true,
                                tools: {
                                    download: true,
                                    selection: true,
                                    zoom: true,
                                    zoomin: true,
                                    zoomout: true,
                                    pan: true,
                                    reset: true
                                }
                            }
                        },
                        plotOptions: {
                            candlestick: {
                                colors: {
                                    upward: '#34c759',
                                    downward: '#ff3b30'
                                },
                                wick: {
                                    useFillColor: true
                                }
                            }
                        },
                        xaxis: {
                            type: 'datetime',
                            labels: {
                                datetimeFormatter: {
                                    year: 'yyyy',
                                    month: "MMM 'yy",
                                    day: 'dd MMM'
                                },
                                style: {
                                    colors: '#666',
                                    fontSize: '12px'
                                }
                            },
                            axisBorder: {
                                show: true,
                                color: '#e0e0e0'
                            },
                            axisTicks: {
                                show: true,
                                color: '#e0e0e0'
                            }
                        },
                        yaxis: {
                            labels: {
                                formatter: function(val) {
                                    return '$' + val.toFixed(2);
                                },
                                style: {
                                    colors: '#666',
                                    fontSize: '12px'
                                }
                            },
                            tooltip: {
                                enabled: true
                            }
                        },
                        tooltip: {
                            custom: function({ seriesIndex, dataPointIndex, w }) {
                                const o = w.globals.seriesCandleO[seriesIndex][dataPointIndex];
                                const h = w.globals.seriesCandleH[seriesIndex][dataPointIndex];
                                const l = w.globals.seriesCandleL[seriesIndex][dataPointIndex];
                                const c = w.globals.seriesCandleC[seriesIndex][dataPointIndex];
                                const date = new Date(w.globals.seriesX[seriesIndex][dataPointIndex]);
                                const formattedDate = date.toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric', 
                                    year: 'numeric' 
                                });
                                
                                return (
                                    '<div class="apexcharts-tooltip-candlestick">' +
                                    '<div>' + formattedDate + '</div>' +
                                    '<div>Open: <span>$' + o.toFixed(2) + '</span></div>' +
                                    '<div>High: <span>$' + h.toFixed(2) + '</span></div>' +
                                    '<div>Low: <span>$' + l.toFixed(2) + '</span></div>' +
                                    '<div>Close: <span>$' + c.toFixed(2) + '</span></div>' +
                                    '</div>'
                                );
                            }
                        },
                        grid: {
                            borderColor: '#f1f1f1',
                            strokeDashArray: 4,
                            xaxis: {
                                lines: {
                                    show: true
                                }
                            },
                            yaxis: {
                                lines: {
                                    show: true
                                }
                            }
                        }
                    };
                    
                    // If chart already exists, destroy it first
                    if (chart) {
                        chart.destroy();
                    }
                    
                    chart = new ApexCharts(document.querySelector("#chart"), options);
                    chart.render();
                    
                    document.getElementById('loading').style.display = 'none';
                    return chart;
                } else {
                    // Fallback to default chart creation if no specific chartData is provided
                    document.getElementById('loading').style.display = 'flex';
                    
                    const chartData = await fetchStockChart(ticker);
                    if (!chartData || !Array.isArray(chartData) || chartData.length === 0) {
                        document.getElementById('chart').innerHTML = '<div class="error-message">Unable to load chart data</div>';
                        document.getElementById('loading').style.display = 'none';
                        return null;
                    }
                    
                    const processedData = processChartData(chartData, days);
                    if (!processedData || processedData.length === 0) {
                        document.getElementById('chart').innerHTML = '<div class="error-message">Unable to process chart data</div>';
                        document.getElementById('loading').style.display = 'none';
                        return null;
                    }
                    
                    // Determine appropriate chart type and options based on timeframe
                    const isSmallTimeframe = days <= 7;
                    
                    const options = {
                        series: [{
                            name: ticker,
                            data: processedData
                        }],
                        chart: {
                            type: 'candlestick',
                            height: 500,
                            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif',
                            background: 'transparent',
                            animations: {
                                enabled: true,
                                easing: 'easeinout',
                                speed: 800
                            },
                            toolbar: {
                                show: true,
                                tools: {
                                    download: true,
                                    selection: true,
                                    zoom: true,
                                    zoomin: true,
                                    zoomout: true,
                                    pan: true,
                                    reset: true
                                }
                            }
                        },
                        plotOptions: {
                            candlestick: {
                                colors: {
                                    upward: '#34c759',
                                    downward: '#ff3b30'
                                },
                                wick: {
                                    useFillColor: true
                                }
                            }
                        },
                        xaxis: {
                            type: 'datetime',
                            labels: {
                                datetimeFormatter: {
                                    year: 'yyyy',
                                    month: "MMM 'yy",
                                    day: 'dd MMM'
                                },
                                style: {
                                    colors: '#666',
                                    fontSize: '12px'
                                }
                            },
                            axisBorder: {
                                show: true,
                                color: '#e0e0e0'
                            },
                            axisTicks: {
                                show: true,
                                color: '#e0e0e0'
                            }
                        },
                        yaxis: {
                            labels: {
                                formatter: function(val) {
                                    return '$' + val.toFixed(2);
                                },
                                style: {
                                    colors: '#666',
                                    fontSize: '12px'
                                }
                            },
                            tooltip: {
                                enabled: true
                            }
                        },
                        tooltip: {
                            custom: function({ seriesIndex, dataPointIndex, w }) {
                                const o = w.globals.seriesCandleO[seriesIndex][dataPointIndex];
                                const h = w.globals.seriesCandleH[seriesIndex][dataPointIndex];
                                const l = w.globals.seriesCandleL[seriesIndex][dataPointIndex];
                                const c = w.globals.seriesCandleC[seriesIndex][dataPointIndex];
                                const date = new Date(w.globals.seriesX[seriesIndex][dataPointIndex]);
                                const formattedDate = date.toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric', 
                                    year: 'numeric' 
                                });
                                
                                return (
                                    '<div class="apexcharts-tooltip-candlestick">' +
                                    '<div>' + formattedDate + '</div>' +
                                    '<div>Open: <span>$' + o.toFixed(2) + '</span></div>' +
                                    '<div>High: <span>$' + h.toFixed(2) + '</span></div>' +
                                    '<div>Low: <span>$' + l.toFixed(2) + '</span></div>' +
                                    '<div>Close: <span>$' + c.toFixed(2) + '</span></div>' +
                                    '</div>'
                                );
                            }
                        },
                        grid: {
                            borderColor: '#f1f1f1',
                            strokeDashArray: 4,
                            xaxis: {
                                lines: {
                                    show: true
                                }
                            },
                            yaxis: {
                                lines: {
                                    show: true
                                }
                            }
                        }
                    };
                    
                    // If chart already exists, destroy it first
                    if (chart) {
                        chart.destroy();
                    }
                    
                    chart = new ApexCharts(document.querySelector("#chart"), options);
                    chart.render();
                    
                    document.getElementById('loading').style.display = 'none';
                    return chart;
                }
                
            } catch (error) {
                console.error('Error creating chart:', error);
                document.getElementById('chart').innerHTML = `<div class="error-message">Error creating chart: ${error.message}</div>`;
                document.getElementById('loading').style.display = 'none';
                return null;
            }
        }

        async function updatePortfolioSummary() {
            // This function would be implemented if we had portfolio functionality
        }

        async function createMLForecastChart(ticker) {
            try {
                document.getElementById('ml-loading').style.display = 'flex';
                
                // Fetch ML prediction data
                const mlData = await fetchMLPrediction(ticker);
                if (!mlData) {
                    document.getElementById('ml-chart').innerHTML = '<div class="error-message">Unable to load ML forecast data</div>';
                    document.getElementById('ml-loading').style.display = 'none';
                    return;
                }
                
                // Fetch ML evaluation data for accuracy metrics
                const evalData = await fetchMLEvaluation(ticker);
                
                // Process forecast data
                const historicalData = [];
                const forecastData = [];
                
                // Fetch historical data directly to ensure we have the right data
                const chartData = await fetchStockChart(ticker);
                if (chartData && Array.isArray(chartData) && chartData.length > 0) {
                    // Get last 60 days of historical data for better visualization
                    const cutoffDate = new Date();
                    cutoffDate.setDate(cutoffDate.getDate() - 60);
                    
                    const filteredData = chartData.filter(item => new Date(item.date) >= cutoffDate);
                    
                    filteredData.forEach(item => {
                        historicalData.push({
                            x: new Date(item.date).getTime(),
                            y: item.close
                        });
                    });
                }
                
                // Process forecast data
                if (mlData.forecast && mlData.forecast.length > 0) {
                    const lastDate = new Date(mlData.last_date);
                    
                    mlData.forecast.forEach(item => {
                        const forecastDate = new Date(lastDate);
                        forecastDate.setDate(forecastDate.getDate() + item.day);
                        
                        forecastData.push({
                            x: forecastDate.getTime(),
                            y: item.price
                        });
                    });
                }
                
                // Create the chart
                const options = {
                    series: [
                        {
                            name: 'Historical',
                            data: historicalData
                        },
                        {
                            name: 'Forecast',
                            data: forecastData
                        }
                    ],
                    chart: {
                        height: 500,
                        type: 'area',
                        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif',
                        animations: {
                            enabled: true,
                            easing: 'easeinout',
                            speed: 800
                        },
                        toolbar: {
                            show: true
                        },
                        zoom: {
                            enabled: true
                        }
                    },
                    dataLabels: {
                        enabled: false
                    },
                    stroke: {
                        curve: 'smooth',
                        width: [2, 2]
                    },
                    colors: ['#3a86ff', '#38b000'],
                    fill: {
                        type: 'gradient',
                        gradient: {
                            shadeIntensity: 1,
                            opacityFrom: 0.7,
                            opacityTo: 0.2,
                            stops: [0, 100]
                        }
                    },
                    xaxis: {
                        type: 'datetime',
                        labels: {
                            datetimeFormatter: {
                                year: 'yyyy',
                                month: "MMM 'yy",
                                day: 'dd MMM'
                            },
                            style: {
                                colors: '#666',
                                fontSize: '12px'
                            }
                        },
                        axisBorder: {
                            show: true,
                            color: '#e0e0e0'
                        },
                        axisTicks: {
                            show: true,
                            color: '#e0e0e0'
                        }
                    },
                    yaxis: {
                        labels: {
                            formatter: function(val) {
                                return '$' + val.toFixed(2);
                            },
                            style: {
                                colors: '#666',
                                fontSize: '12px'
                            }
                        },
                        title: {
                            text: 'Price',
                            style: {
                                fontSize: '14px',
                                fontWeight: 500,
                                color: '#666'
                            }
                        }
                    },
                    tooltip: {
                        shared: true,
                        intersect: false,
                        x: {
                            format: 'MMM dd, yyyy'
                        },
                        y: {
                            formatter: function(val) {
                                return '$' + val.toFixed(2);
                            }
                        },
                        style: {
                            fontSize: '12px'
                        }
                    },
                    grid: {
                        borderColor: '#f1f1f1',
                        strokeDashArray: 4,
                        xaxis: {
                            lines: {
                                show: true
                            }
                        },
                        yaxis: {
                            lines: {
                                show: true
                            }
                        }
                    },
                    legend: {
                        show: true,
                        position: 'top',
                        horizontalAlign: 'right',
                        fontSize: '14px',
                        markers: {
                            width: 10,
                            height: 10,
                            radius: 5
                        }
                    },
                    annotations: {
                        xaxis: [
                            {
                                x: new Date(mlData.last_date).getTime(),
                                strokeDashArray: 0,
                                borderColor: '#888',
                                label: {
                                    borderColor: '#888',
                                    style: {
                                        color: '#fff',
                                        background: '#888',
                                        fontSize: '10px',
                                        fontWeight: 500,
                                        padding: {
                                            left: 6,
                                            right: 6,
                                            top: 3,
                                            bottom: 3
                                        }
                                    },
                                    text: 'Today'
                                }
                            }
                        ]
                    },
                    markers: {
                        size: 0,
                        strokeWidth: 3,
                        hover: {
                            size: 6
                        }
                    }
                };
                
                // Create the chart
                const mlChart = new ApexCharts(document.getElementById('ml-chart'), options);
                mlChart.render();
                
                // Update metrics
                const forecastValue = document.getElementById('ml-forecast-value');
                forecastValue.textContent = `$${mlData.avg_predicted_price.toFixed(2)}`;
                
                const changeValue = document.getElementById('ml-change-value');
                const changePercent = mlData.price_change_percent;
                changeValue.textContent = `${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%`;
                changeValue.className = `ml-metric-value ${changePercent >= 0 ? 'positive' : 'negative'}`;
                
                const accuracyValue = document.getElementById('ml-accuracy-value');
                if (evalData && evalData.directional_accuracy) {
                    accuracyValue.textContent = `${evalData.directional_accuracy.toFixed(1)}%`;
                } else {
                    accuracyValue.textContent = 'N/A';
                }
                
                // Update model info
                const infoPanel = document.querySelector('.ml-info-panel');
                const infoTitle = infoPanel.querySelector('.ml-info-title');
                const infoContent = infoPanel.querySelector('.ml-info-content');
                
                // Check if it's a fallback model
                if (mlData.is_fallback) {
                    infoTitle.innerHTML = `Simple Trend Model <span class="ml-badge ml-badge-beta">FALLBACK</span>`;
                    infoContent.textContent = `This is a simplified trend-following model used as a fallback when the advanced ML model is unavailable. It analyzes recent moving averages to determine price direction and projects future prices based on the current trend.`;
                } else {
                    infoTitle.innerHTML = `${mlData.model_type || 'AI Prediction Model'} <span class="ml-badge ml-badge-beta">BETA</span>`;
                    infoContent.textContent = `This forecast is generated using an advanced LSTM neural network trained on historical price data and technical indicators. The model analyzes patterns in price movements, volatility, and momentum to predict future price trends.`;
                }
                
                document.getElementById('ml-loading').style.display = 'none';
                
            } catch (error) {
                console.error('Error creating ML forecast chart:', error);
                document.getElementById('ml-chart').innerHTML = `<div class="error-message">Error creating ML forecast chart: ${error.message}</div>`;
                document.getElementById('ml-loading').style.display = 'none';
            }
        }

        function getTrendClass(trend) {
            if (!trend) return '';
            
            if (trend.includes('strong_uptrend')) return 'trend-strong-up';
            if (trend.includes('uptrend')) return 'trend-up';
            if (trend.includes('strong_downtrend')) return 'trend-strong-down';
            if (trend.includes('downtrend')) return 'trend-down';
            
            return 'trend-neutral';
        }

        function formatTrendName(trend) {
            if (!trend) return '-';
            
            // Convert snake_case to Title Case with spaces
            return trend.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        async function updateTechnicalAnalysis(ticker, period = '1y', technicalData = null) {
            try {
                document.getElementById('technical-loading').style.display = 'flex';
                
                // If technicalData is provided, use it for updating
                if (technicalData) {
                    // Update summary
                    document.getElementById('technical-summary').textContent = technicalData.summary || 'No summary available';
                    
                    // Update trend
                    const trendElement = document.getElementById('trend');
                    trendElement.textContent = formatTrendName(technicalData.trend);
                    trendElement.className = 'indicator-value ' + getTrendClass(technicalData.trend);
                    
                    // Update price change
                    const priceChangeElement = document.getElementById('price-change');
                    const priceChangePercent = technicalData.price_change_percent;
                    if (priceChangePercent !== null && priceChangePercent !== undefined) {
                        const formattedChange = priceChangePercent.toFixed(2) + '%';
                        priceChangeElement.textContent = formattedChange;
                        priceChangeElement.className = 'indicator-value ' + (priceChangePercent >= 0 ? 'positive' : 'negative');
                    } else {
                        priceChangeElement.textContent = '-';
                        priceChangeElement.className = 'indicator-value';
                    }
                    
                    // Update moving averages
                    const indicators = technicalData.indicators || {};
                    const movingAverages = indicators.moving_averages || {};
                    
                    document.getElementById('ma20').textContent = movingAverages.ma20 ? '$' + movingAverages.ma20.toFixed(2) : '-';
                    document.getElementById('ma50').textContent = movingAverages.ma50 ? '$' + movingAverages.ma50.toFixed(2) : '-';
                    document.getElementById('ma200').textContent = movingAverages.ma200 ? '$' + movingAverages.ma200.toFixed(2) : '-';
                    
                    // Update oscillators
                    document.getElementById('rsi').textContent = indicators.rsi ? indicators.rsi.toFixed(2) : '-';
                    
                    const macd = indicators.macd || {};
                    document.getElementById('macd').textContent = macd.macd ? macd.macd.toFixed(4) : '-';
                    
                    // Update support & resistance
                    if (technicalData.support_resistance && technicalData.support_resistance.support_levels && technicalData.support_resistance.support_levels.length > 0) {
                        document.getElementById('support').textContent = '$' + technicalData.support_resistance.support_levels[0].toFixed(2);
                    } else {
                        document.getElementById('support').textContent = '-';
                    }
                    
                    if (technicalData.support_resistance && technicalData.support_resistance.resistance_levels && technicalData.support_resistance.resistance_levels.length > 0) {
                        document.getElementById('resistance').textContent = '$' + technicalData.support_resistance.resistance_levels[0].toFixed(2);
                    } else {
                        document.getElementById('resistance').textContent = '-';
                    }
                    
                    // Update patterns
                    const patternsElement = document.getElementById('patterns');
                    if (technicalData.patterns && technicalData.patterns.detected_patterns && technicalData.patterns.detected_patterns.length > 0) {
                        patternsElement.innerHTML = technicalData.patterns.detected_patterns
                            .map(pattern => `<div class="pattern-item">${formatTrendName(pattern)}</div>`)
                            .join('');
                    } else {
                        patternsElement.textContent = 'No patterns detected';
                    }
                } else {
                    // Fetch all technical data
                    const [summaryData, supportResistanceData, patternsData] = await Promise.all([
                        fetchTechnicalSummary(ticker, period),
                        fetchSupportResistance(ticker, period),
                        fetchPatterns(ticker, period)
                    ]);
                    
                    if (!summaryData) {
                        document.getElementById('technical-content').innerHTML = '<div class="error-message">Unable to load technical analysis data</div>';
                        document.getElementById('technical-loading').style.display = 'none';
                        return;
                    }
                    
                    // Update summary
                    document.getElementById('technical-summary').textContent = summaryData.summary || 'No summary available';
                    
                    // Update trend
                    const trendElement = document.getElementById('trend');
                    trendElement.textContent = formatTrendName(summaryData.trend);
                    trendElement.className = 'indicator-value ' + getTrendClass(summaryData.trend);
                    
                    // Update price change
                    const priceChangeElement = document.getElementById('price-change');
                    const priceChangePercent = summaryData.price_change_percent;
                    if (priceChangePercent !== null && priceChangePercent !== undefined) {
                        const formattedChange = priceChangePercent.toFixed(2) + '%';
                        priceChangeElement.textContent = formattedChange;
                        priceChangeElement.className = 'indicator-value ' + (priceChangePercent >= 0 ? 'positive' : 'negative');
                    } else {
                        priceChangeElement.textContent = '-';
                        priceChangeElement.className = 'indicator-value';
                    }
                    
                    // Update moving averages
                    const indicators = {}; // Placeholder, actual data will be fetched later
                    const movingAverages = {};
                    
                    document.getElementById('ma20').textContent = '-';
                    document.getElementById('ma50').textContent = '-';
                    document.getElementById('ma200').textContent = '-';
                    
                    // Update oscillators
                    document.getElementById('rsi').textContent = '-';
                    
                    const macd = {};
                    document.getElementById('macd').textContent = '-';
                    
                    // Update support & resistance
                    if (supportResistanceData && supportResistanceData.support_levels && supportResistanceData.support_levels.length > 0) {
                        document.getElementById('support').textContent = '$' + supportResistanceData.support_levels[0].toFixed(2);
                    } else {
                        document.getElementById('support').textContent = '-';
                    }
                    
                    if (supportResistanceData && supportResistanceData.resistance_levels && supportResistanceData.resistance_levels.length > 0) {
                        document.getElementById('resistance').textContent = '$' + supportResistanceData.resistance_levels[0].toFixed(2);
                    } else {
                        document.getElementById('resistance').textContent = '-';
                    }
                    
                    // Update patterns
                    const patternsElement = document.getElementById('patterns');
                    if (patternsData && patternsData.detected_patterns && patternsData.detected_patterns.length > 0) {
                        patternsElement.innerHTML = patternsData.detected_patterns
                            .map(pattern => `<div class="pattern-item">${formatTrendName(pattern)}</div>`)
                            .join('');
                    } else {
                        patternsElement.textContent = 'No patterns detected';
                    }
                }
                
                document.getElementById('technical-loading').style.display = 'none';
                
            } catch (error) {
                console.error('Error updating technical analysis:', error);
                document.getElementById('technical-content').innerHTML = `<div class="error-message">Error loading technical analysis: ${error.message}</div>`;
                document.getElementById('technical-loading').style.display = 'none';
            }
        }

        async function updateSentimentAnalysis(ticker, days = 7, sentimentData = null) {
            try {
                document.getElementById('sentiment-loading').style.display = 'flex';

                // If sentimentData is provided, use it for updating
                if (sentimentData) {
                    // Update summary
                    document.getElementById('sentiment-summary').textContent = sentimentData.summary || 'No sentiment summary available';
                    
                    // Update sentiment score and label
                    const sentimentLabel = sentimentData.sentiment_label || '-';
                    document.getElementById('sentiment-label').textContent = sentimentLabel.charAt(0).toUpperCase() + sentimentLabel.slice(1);
                    
                    // Normalize sentiment score to 0-100% for the meter
                    const sentimentScore = sentimentData.sentiment_score || 0;
                    const normalizedScore = ((sentimentScore + 1) / 2) * 100; // Convert -1 to 1 range to 0-100%
                    document.getElementById('sentiment-meter-bar').style.width = `${normalizedScore}%`;
                    
                    // Color based on sentiment
                    if (sentimentScore > 0.2) {
                        document.getElementById('sentiment-meter-bar').style.backgroundColor = '#34c759'; // Positive
                    } else if (sentimentScore < -0.2) {
                        document.getElementById('sentiment-meter-bar').style.backgroundColor = '#ff3b30'; // Negative
                    } else {
                        document.getElementById('sentiment-meter-bar').style.backgroundColor = '#999'; // Neutral
                    }
                    
                    // Update distribution bars
                    const positive = sentimentData.positive || 0;
                    const neutral = sentimentData.neutral || 0;
                    const negative = sentimentData.negative || 0;
                    const total = positive + neutral + negative || 1; // Avoid division by zero
                    
                    document.getElementById('positive-value').textContent = positive;
                    document.getElementById('neutral-value').textContent = neutral;
                    document.getElementById('negative-value').textContent = negative;
                    
                    document.getElementById('positive-bar').style.height = `${(positive / total) * 100}%`;
                    document.getElementById('neutral-bar').style.height = `${(neutral / total) * 100}%`;
                    document.getElementById('negative-bar').style.height = `${(negative / total) * 100}%`;
                    
                    // Update articles
                    const articlesContainer = document.getElementById('articles-container');
                    articlesContainer.innerHTML = '';
                    
                    if (sentimentData.articles && sentimentData.articles.length > 0) {
                        sentimentData.articles.forEach(article => {
                            const articleElement = document.createElement('div');
                            articleElement.classList.add('article-item');
                            
                            // Format the date
                            const articleDate = new Date(article.date).toLocaleDateString();
                            
                            articleElement.innerHTML = `
                                <h4>${article.title || 'No title'}</h4>
                                <p>${article.summary || article.snippet || 'No summary available'}</p>
                                <p><strong>Source:</strong> ${article.source || 'Unknown'}</p>
                                <p><strong>Date:</strong> ${articleDate}</p>
                            `;
                            articlesContainer.appendChild(articleElement);
                        });
                    } else {
                        articlesContainer.innerHTML = '<p class="article-loading">No recent news articles found.</p>';
                    }
                } else {
                    // Fetch all sentiment data
                    const [summaryData, scoreData, distributionData, articlesData] = await Promise.all([
                        fetchSentimentSummary(ticker, days),
                        fetchSentimentScore(ticker, days),
                        fetchSentimentDistribution(ticker, days),
                        fetchNewsArticles(ticker, days)
                    ]);
                    
                    if (!summaryData || !scoreData || !distributionData) {
                        document.getElementById('sentiment-content').innerHTML = '<div class="error-message">Unable to load sentiment analysis data</div>';
                        document.getElementById('sentiment-loading').style.display = 'none';
                        return;
                    }
                    
                    // Update summary
                    document.getElementById('sentiment-summary').textContent = summaryData.summary || 'No sentiment summary available';
                    
                    // Update sentiment score and label
                    const sentimentLabel = scoreData.sentiment_label || '-';
                    document.getElementById('sentiment-label').textContent = sentimentLabel.charAt(0).toUpperCase() + sentimentLabel.slice(1);
                    
                    // Normalize sentiment score to 0-100% for the meter
                    const sentimentScore = scoreData.sentiment_score || 0;
                    const normalizedScore = ((sentimentScore + 1) / 2) * 100; // Convert -1 to 1 range to 0-100%
                    document.getElementById('sentiment-meter-bar').style.width = `${normalizedScore}%`;
                    
                    // Color based on sentiment
                    if (sentimentScore > 0.2) {
                        document.getElementById('sentiment-meter-bar').style.backgroundColor = '#34c759'; // Positive
                    } else if (sentimentScore < -0.2) {
                        document.getElementById('sentiment-meter-bar').style.backgroundColor = '#ff3b30'; // Negative
                    } else {
                        document.getElementById('sentiment-meter-bar').style.backgroundColor = '#999'; // Neutral
                    }
                    
                    // Update distribution bars
                    const positive = distributionData.positive || 0;
                    const neutral = distributionData.neutral || 0;
                    const negative = distributionData.negative || 0;
                    const total = positive + neutral + negative || 1; // Avoid division by zero
                    
                    document.getElementById('positive-value').textContent = positive;
                    document.getElementById('neutral-value').textContent = neutral;
                    document.getElementById('negative-value').textContent = negative;
                    
                    document.getElementById('positive-bar').style.height = `${(positive / total) * 100}%`;
                    document.getElementById('neutral-bar').style.height = `${(neutral / total) * 100}%`;
                    document.getElementById('negative-bar').style.height = `${(negative / total) * 100}%`;
                    
                    // Update articles
                    const articlesContainer = document.getElementById('articles-container');
                    articlesContainer.innerHTML = '';
                    
                    if (articlesData && articlesData.articles && articlesData.articles.length > 0) {
                        articlesData.articles.forEach(article => {
                            const articleElement = document.createElement('div');
                            articleElement.classList.add('article-item');
                            
                            // Format the date
                            const articleDate = new Date(article.date).toLocaleDateString();
                            
                            articleElement.innerHTML = `
                                <h4>${article.title || 'No title'}</h4>
                                <p>${article.summary || article.snippet || 'No summary available'}</p>
                                <p><strong>Source:</strong> ${article.source || 'Unknown'}</p>
                                <p><strong>Date:</strong> ${articleDate}</p>
                            `;
                            articlesContainer.appendChild(articleElement);
                        });
                    } else {
                        articlesContainer.innerHTML = '<p class="article-loading">No recent news articles found.</p>';
                    }
                }
                
                document.getElementById('sentiment-loading').style.display = 'none';
                
            } catch (error) {
                console.error('Error updating sentiment analysis:', error);
                document.getElementById('sentiment-content').innerHTML = `<div class="error-message">Error loading sentiment analysis: ${error.message}</div>`;
                document.getElementById('sentiment-loading').style.display = 'none';
            }
        }

        async function updatePrediction(ticker, predictionData = null) {
            try {
                document.getElementById('prediction-loading').style.display = 'flex';
                
                // If predictionData is provided, use it for updating
                if (predictionData) {
                    // Update recommendation
                    const recommendationElement = document.getElementById('recommendation');
                    const recommendation = predictionData.recommendation || 'HOLD';
                    recommendationElement.textContent = recommendation.toUpperCase();
                    recommendationElement.className = 'recommendation';
                    
                    // Add class based on recommendation
                    if (recommendation.toLowerCase().includes('buy')) {
                        recommendationElement.classList.add('buy');
                    } else if (recommendation.toLowerCase().includes('sell')) {
                        recommendationElement.classList.add('sell');
                    } else {
                        recommendationElement.classList.add('hold');
                    }
                    
                    // Update confidence
                    const confidence = predictionData.confidence || 0;
                    document.getElementById('confidence-value').textContent = `${(confidence * 100).toFixed(0)}%`;
                    
                    // Update prediction details
                    const currentPrice = predictionData.current_price || 0;
                    document.getElementById('current-price-prediction').textContent = `$${currentPrice.toFixed(2)}`;
                    
                    const predictedChange = predictionData.predicted_change || 0;
                    const predictedChangeElement = document.getElementById('predicted-change');
                    predictedChangeElement.textContent = `$${Math.abs(predictedChange).toFixed(2)}`;
                    predictedChangeElement.className = 'prediction-value';
                    if (predictedChange > 0) {
                        predictedChangeElement.classList.add('positive');
                    } else if (predictedChange < 0) {
                        predictedChangeElement.classList.add('negative');
                    }
                    
                    const predictedReturn = predictionData.predicted_change_percent || 0;
                    const predictedReturnElement = document.getElementById('predicted-return');
                    predictedReturnElement.textContent = `${Math.abs(predictedReturn).toFixed(2)}%`;
                    predictedReturnElement.className = 'prediction-value';
                    if (predictedReturn > 0) {
                        predictedReturnElement.classList.add('positive');
                    } else if (predictedReturn < 0) {
                        predictedReturnElement.classList.add('negative');
                    }
                    
                    // Update summary
                    document.getElementById('prediction-summary').textContent = predictionData.summary || 'No prediction summary available';
                    
                    // Update factors
                    if (predictionData.factors) {
                        // Technical factors
                        const technicalFactorsList = document.getElementById('technical-factors');
                        technicalFactorsList.innerHTML = '';
                        const technicalFactors = predictionData.factors.technical || {};
                        
                        if (Object.keys(technicalFactors).length > 0) {
                            Object.entries(technicalFactors).forEach(([key, value]) => {
                                const li = document.createElement('li');
                                li.textContent = `${key.replace(/_/g, ' ')}: ${value}`;
                                technicalFactorsList.appendChild(li);
                            });
                        } else {
                            technicalFactorsList.innerHTML = '<li>No technical factors available</li>';
                        }
                        
                        // Fundamental factors
                        const fundamentalFactorsList = document.getElementById('fundamental-factors');
                        fundamentalFactorsList.innerHTML = '';
                        const fundamentalFactors = predictionData.factors.fundamental || {};
                        
                        if (Object.keys(fundamentalFactors).length > 0) {
                            Object.entries(fundamentalFactors).forEach(([key, value]) => {
                                const li = document.createElement('li');
                                li.textContent = `${key.replace(/_/g, ' ')}: ${value}`;
                                fundamentalFactorsList.appendChild(li);
                            });
                        } else {
                            fundamentalFactorsList.innerHTML = '<li>No fundamental factors available</li>';
                        }
                        
                        // Sentiment factors
                        const sentimentFactorsList = document.getElementById('sentiment-factors');
                        sentimentFactorsList.innerHTML = '';
                        const sentimentFactors = predictionData.factors.sentiment || {};
                        
                        if (Object.keys(sentimentFactors).length > 0) {
                            Object.entries(sentimentFactors).forEach(([key, value]) => {
                                const li = document.createElement('li');
                                li.textContent = `${key.replace(/_/g, ' ')}: ${value}`;
                                sentimentFactorsList.appendChild(li);
                            });
                        } else {
                            sentimentFactorsList.innerHTML = '<li>No sentiment factors available</li>';
                        }
                    } else {
                        document.getElementById('technical-factors').innerHTML = '<li>No technical factors available</li>';
                        document.getElementById('fundamental-factors').innerHTML = '<li>No fundamental factors available</li>';
                        document.getElementById('sentiment-factors').innerHTML = '<li>No sentiment factors available</li>';
                    }
                } else {
                    // Fetch prediction data
                    const [summaryData, factorsData] = await Promise.all([
                        fetchPredictionSummary(ticker),
                        fetchPredictionFactors(ticker)
                    ]);
                    
                    if (!summaryData) {
                        document.getElementById('prediction-content').innerHTML = '<div class="error-message">Unable to load prediction data</div>';
                        document.getElementById('prediction-loading').style.display = 'none';
                        return;
                    }
                    
                    // Update recommendation
                    const recommendationElement = document.getElementById('recommendation');
                    const recommendation = summaryData.recommendation || 'HOLD';
                    recommendationElement.textContent = recommendation.toUpperCase();
                    recommendationElement.className = 'recommendation';
                    
                    // Add class based on recommendation
                    if (recommendation.toLowerCase().includes('buy')) {
                        recommendationElement.classList.add('buy');
                    } else if (recommendation.toLowerCase().includes('sell')) {
                        recommendationElement.classList.add('sell');
                    } else {
                        recommendationElement.classList.add('hold');
                    }
                    
                    // Update confidence
                    const confidence = summaryData.confidence || 0;
                    document.getElementById('confidence-value').textContent = `${(confidence * 100).toFixed(0)}%`;
                    
                    // Update prediction details
                    const currentPrice = summaryData.current_price || 0;
                    document.getElementById('current-price-prediction').textContent = `$${currentPrice.toFixed(2)}`;
                    
                    const predictedChange = summaryData.predicted_change || 0;
                    const predictedChangeElement = document.getElementById('predicted-change');
                    predictedChangeElement.textContent = `$${Math.abs(predictedChange).toFixed(2)}`;
                    predictedChangeElement.className = 'prediction-value';
                    if (predictedChange > 0) {
                        predictedChangeElement.classList.add('positive');
                    } else if (predictedChange < 0) {
                        predictedChangeElement.classList.add('negative');
                    }
                    
                    const predictedReturn = summaryData.predicted_change_percent || 0;
                    const predictedReturnElement = document.getElementById('predicted-return');
                    predictedReturnElement.textContent = `${Math.abs(predictedReturn).toFixed(2)}%`;
                    predictedReturnElement.className = 'prediction-value';
                    if (predictedReturn > 0) {
                        predictedReturnElement.classList.add('positive');
                    } else if (predictedReturn < 0) {
                        predictedReturnElement.classList.add('negative');
                    }
                    
                    // Update summary
                    document.getElementById('prediction-summary').textContent = summaryData.summary || 'No prediction summary available';
                    
                    // Update factors
                    if (factorsData && factorsData.factors) {
                        // Technical factors
                        const technicalFactorsList = document.getElementById('technical-factors');
                        technicalFactorsList.innerHTML = '';
                        const technicalFactors = factorsData.factors.technical || {};
                        
                        if (Object.keys(technicalFactors).length > 0) {
                            Object.entries(technicalFactors).forEach(([key, value]) => {
                                const li = document.createElement('li');
                                li.textContent = `${key.replace(/_/g, ' ')}: ${value}`;
                                technicalFactorsList.appendChild(li);
                            });
                        } else {
                            technicalFactorsList.innerHTML = '<li>No technical factors available</li>';
                        }
                        
                        // Fundamental factors
                        const fundamentalFactorsList = document.getElementById('fundamental-factors');
                        fundamentalFactorsList.innerHTML = '';
                        const fundamentalFactors = factorsData.factors.fundamental || {};
                        
                        if (Object.keys(fundamentalFactors).length > 0) {
                            Object.entries(fundamentalFactors).forEach(([key, value]) => {
                                const li = document.createElement('li');
                                li.textContent = `${key.replace(/_/g, ' ')}: ${value}`;
                                fundamentalFactorsList.appendChild(li);
                            });
                        } else {
                            fundamentalFactorsList.innerHTML = '<li>No fundamental factors available</li>';
                        }
                        
                        // Sentiment factors
                        const sentimentFactorsList = document.getElementById('sentiment-factors');
                        sentimentFactorsList.innerHTML = '';
                        const sentimentFactors = factorsData.factors.sentiment || {};
                        
                        if (Object.keys(sentimentFactors).length > 0) {
                            Object.entries(sentimentFactors).forEach(([key, value]) => {
                                const li = document.createElement('li');
                                li.textContent = `${key.replace(/_/g, ' ')}: ${value}`;
                                sentimentFactorsList.appendChild(li);
                            });
                        } else {
                            sentimentFactorsList.innerHTML = '<li>No sentiment factors available</li>';
                        }
                    } else {
                        document.getElementById('technical-factors').innerHTML = '<li>No technical factors available</li>';
                        document.getElementById('fundamental-factors').innerHTML = '<li>No fundamental factors available</li>';
                        document.getElementById('sentiment-factors').innerHTML = '<li>No sentiment factors available</li>';
                    }
                }
                
                document.getElementById('prediction-loading').style.display = 'none';
                
            } catch (error) {
                console.error('Error updating prediction:', error);
                document.getElementById('prediction-content').innerHTML = `<div class="error-message">Error loading prediction: ${error.message}</div>`;
                document.getElementById('prediction-loading').style.display = 'none';
            }
        }

        async function updateStockDisplay(ticker, days = currentTimeframe) {
            try {
                // Save the new ticker and timeframe
                currentTicker = ticker.toUpperCase();
                currentTimeframe = days;
                
                // Show loading indicators
                document.getElementById('loading').style.display = 'flex';
                document.getElementById('technical-loading').style.display = 'flex';
                document.getElementById('sentiment-loading').style.display = 'flex';
                document.getElementById('prediction-loading').style.display = 'flex';
                
                // Update ticker display immediately but keep old data until new data loads
                document.getElementById('ticker').textContent = currentTicker;
                
                // Update active timeframe button
                document.querySelectorAll('.timeframe-button').forEach(btn => {
                    if (parseInt(btn.dataset.days) === days) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                
                // Fetch stock info first
                const stock = await fetchStockInfo(currentTicker);
                if (!stock) {
                    document.getElementById('price').textContent = 'Not found';
                    document.getElementById('company-name').textContent = '';
                    document.getElementById('chart').innerHTML = '<div class="not-found">Stock data not found for this ticker</div>';
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('technical-content').innerHTML = '<div class="not-found">Technical analysis not available</div>';
                    document.getElementById('technical-loading').style.display = 'none';
                    document.getElementById('sentiment-content').innerHTML = '<div class="not-found">Sentiment analysis not available</div>';
                    document.getElementById('sentiment-loading').style.display = 'none';
                    document.getElementById('prediction-content').innerHTML = '<div class="not-found">AI prediction not available</div>';
                    document.getElementById('prediction-loading').style.display = 'none';
                    return;
                }
                
                // Update ticker and company name
                document.getElementById('ticker').textContent = stock.ticker;
                document.getElementById('company-name').textContent = stock.company_name || '';
                
                // Update price
                const priceElement = document.getElementById('price');
                priceElement.textContent = `$${stock.current_price.toFixed(2)}`;
                
                // Reset classes
                priceElement.classList.remove('positive', 'negative');
                
                // Fetch all data in parallel
                const [chartData, technicalData, sentimentData, predictionData] = await Promise.all([
                    fetchStockChart(currentTicker),
                    fetchTechnicalSummary(currentTicker, getPeriodFromDays(days)),
                    fetchSentimentSummary(currentTicker, days),
                    fetchPrediction(currentTicker)
                ]);
                
                // Process chart data
                if (chartData && Array.isArray(chartData) && chartData.length > 1) {
                    const lastPrice = chartData[chartData.length - 1].close;
                    const previousPrice = chartData[chartData.length - 2].close;
                    const priceChange = lastPrice - previousPrice;
                    
                    if (priceChange > 0) {
                        priceElement.classList.add('positive');
                    } else if (priceChange < 0) {
                        priceElement.classList.add('negative');
                    }
                    
                    // Create chart with specified timeframe
                    await createChart(currentTicker, days, chartData);
                } else {
                    document.getElementById('chart').innerHTML = '<div class="error-message">Unable to load chart data</div>';
                }
                document.getElementById('loading').style.display = 'none';
                
                // Update technical analysis
                await updateTechnicalAnalysis(currentTicker, getPeriodFromDays(days), technicalData);
                
                // Update sentiment analysis
                await updateSentimentAnalysis(currentTicker, days, sentimentData);
                
                // Update prediction
                await updatePrediction(currentTicker, predictionData);
                
                // Update ML chart if it's visible
                const mlTabActive = document.querySelector('.chart-tab[data-tab="ml"]').classList.contains('active');
                if (mlTabActive) {
                    await createMLForecastChart(currentTicker);
                } else {
                    // Clear existing ML chart data so it will be refreshed when tab is clicked
                    document.getElementById('ml-chart').innerHTML = '';
                }
                
            } catch (error) {
                console.error('Error updating stock display:', error);
                document.getElementById('price').textContent = 'Error';
                document.getElementById('chart').innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                document.getElementById('loading').style.display = 'none';
                document.getElementById('technical-loading').style.display = 'none';
                document.getElementById('sentiment-loading').style.display = 'none';
                document.getElementById('prediction-loading').style.display = 'none';
            }
        }
        
        function getPeriodFromDays(days) {
            // Map our timeframe days to API period parameter
            if (days <= 7) return '5d';
            if (days <= 30) return '1mo';
            if (days <= 90) return '3mo';
            if (days <= 180) return '6mo';
            return '1y';
        }

        // Initialize
        async function init() {
            console.log(`Initializing...`);
            
            // Check if there's a ticker in the URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const tickerParam = urlParams.get('ticker');
            if (tickerParam) {
                currentTicker = tickerParam.toUpperCase();
                document.getElementById('ticker-search').value = currentTicker;
            }
            
            // Set up search functionality
            const searchInput = document.getElementById('ticker-search');
            const searchButton = document.getElementById('search-button');
            
            // Flag to prevent multiple simultaneous searches
            let isSearching = false;
            
            searchButton.addEventListener('click', () => {
                const ticker = searchInput.value.trim();
                if (ticker && !isSearching) {
                    isSearching = true;
                    searchButton.disabled = true;
                    searchButton.textContent = 'Loading...';
                    searchButton.classList.add('loading');
                    
                    updateStockDisplay(ticker, currentTimeframe).finally(() => {
                        isSearching = false;
                        searchButton.disabled = false;
                        searchButton.textContent = 'Search';
                        searchButton.classList.remove('loading');
                    });
                }
            });
            
            searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const ticker = searchInput.value.trim();
                    if (ticker && !isSearching) {
                        isSearching = true;
                        searchButton.disabled = true;
                        searchButton.textContent = 'Loading...';
                        searchButton.classList.add('loading');
                        
                        updateStockDisplay(ticker, currentTimeframe).finally(() => {
                            isSearching = false;
                            searchButton.disabled = false;
                            searchButton.textContent = 'Search';
                            searchButton.classList.remove('loading');
                        });
                    }
                }
            });
            
            // Set up timeframe buttons
            document.querySelectorAll('.timeframe-button').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (isSearching) return; // Ignore if already searching
                    
                    const days = parseInt(btn.dataset.days);
                    
                    // Disable all timeframe buttons during loading
                    document.querySelectorAll('.timeframe-button').forEach(b => {
                        b.disabled = true;
                    });
                    
                    updateStockDisplay(currentTicker, days).finally(() => {
                        // Re-enable all timeframe buttons
                        document.querySelectorAll('.timeframe-button').forEach(b => {
                            b.disabled = false;
                        });
                    });
                });
            });
            
            // Set up chart tabs
            document.querySelectorAll('.chart-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    if (isSearching) return; // Ignore if already searching
                    
                    // Update active tab
                    document.querySelectorAll('.chart-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    // Show the selected content
                    const tabName = tab.dataset.tab;
                    document.querySelectorAll('.chart-content').forEach(content => {
                        content.style.display = 'none';
                    });
                    document.getElementById(`${tabName}-chart-content`).style.display = 'block';
                    
                    // Load ML chart if needed
                    if (tabName === 'ml' && !document.getElementById('ml-chart').innerHTML) {
                        createMLForecastChart(currentTicker);
                    }
                });
            });
            
            // Load initial stock with default timeframe
            await updateStockDisplay(currentTicker, currentTimeframe);
            
            // Update current stock every 60 seconds instead of 30
            setInterval(() => {
                if (currentTicker && !isSearching) {
                    updateStockDisplay(currentTicker, currentTimeframe);
                }
            }, 60000);
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html> 